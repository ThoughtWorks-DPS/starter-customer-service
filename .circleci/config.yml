version: 2

defaults: &defaults
  working_directory: ~/project
  environment:
    JVM_OPTS: -Xmx3200m
    TERM: dumb
    JAVA_CONTAINER: circleci/openjdk:8-jdk
    INFRA_CONTAINER: quay.io/thoughtworks_aelab/di-circleci-platform-agent:latest
    GCLOUD_PROJECT_ID: twdps-k8-starter
    GKE_CLUSTER_NAME: k8startercluster
exports: &exports
  - run: |
      NEW_VERSION=`grep 'version' gradle.properties|cut -d'=' -f2`
      echo "export NEW_VERSION=$NEW_VERSION" >> $BASH_ENV

setup_infra: &setup_infra
  - run: |
      k8/create-gcloud-kubectl-context.sh
      docker login -u="$DOCKER_USER" -p="$QUAY_TOKEN" quay.io

jobs:
  build-jar:
    <<: *defaults
    docker:
      # specify the version you desire here
#      - image: circleci/openjdk:8-jdk
      - image: $JAVA_CONTAINER

    steps:
      - checkout
#      - <<: *exports
      - attach_workspace:
          at: ~/project
      # IMPORTANT - circleci needs the AWS credentials setup correctly
      # with a user that can access the s3 bucket used for the maven dependencies

      # Download and cache dependencies
      - restore_cache:
          keys:
          - v1-dependencies-{{ checksum "build.gradle" }}
          # fallback to using the latest cache if no exact match is found
          - v1-dependencies-

      - run: ./gradlew dependencies

      - save_cache:
          paths:
            - ~/.gradle
          key: v1-dependencies-{{ checksum "build.gradle" }}

      # run tests - but not Integration Testing - that's post release
      - run: ./gradlew build test -x integrationTest
      # CREATE THE DOCKER TAG which for now is the new version
      - run: echo "`grep 'version' gradle.properties|cut -d'=' -f2`-$CIRCLE_BUILD_NUM" >> docker.tag

      # since we made the Dockerfile easy to work with locally with Gradle we need to set the
      # JAR_FILE arg in the docker build command

      - persist_to_workspace:
          root: .
          paths:
            - gradle.properties
            - build/libs
            - Dockerfile
            - k8
            - gcloud-secret
            - docker.tag

  build-docker:
    <<: *defaults

    docker:
      - image: $INFRA_CONTAINER
        auth:
          username: $DOCKER_USER
          password: $QUAY_TOKEN

    steps:
      - setup_remote_docker
      - attach_workspace:
          at: ~/project
      - <<: *exports
      - <<: *setup_infra

      # since we made the Dockerfile easy to work with locally with Gradle we need to set the
      # JAR_FILE arg in the docker build command
      - run: echo "export DOCKER_TAG=`cat docker.tag`" >> $BASH_ENV
      - run: docker build --build-arg JAR_FILE=build/libs/customerservice-lastest.jar -t quay.io/thoughtworks_aelab/customerservice:$DOCKER_TAG .
      - run: docker push quay.io/thoughtworks_aelab/customerservice:$DOCKER_TAG

  deploy-service:
    <<: *defaults

    docker:
      - image: $INFRA_CONTAINER
        auth:
          username: $DOCKER_USER
          password: $QUAY_TOKEN

    steps:
      - setup_remote_docker
      - attach_workspace:
          at: ~/project
      - <<: *exports
      - <<: *setup_infra

      # setup the deployment variables
      - run: |
          echo "SERVICE_NAME=customerservice" >> k8-dev.env
          echo "NAMESPACE=dev" >> k8-dev.env
          echo "DOCKER_TAG=$DOCKER_TAG" >> k8-dev.env
          echo "CURRENT_VERSION=$DOCKER_TAG" >> k8-dev.env
          LATEST_VERSION=`kubectl get deployments -n dev -l status=released -o jsonpath='{.items[0].metadata.labels.version}'`
          echo "LATEST_VERSION=$LATEST_VERSION" >> k8-dev.env
          CURRENT_SUBSET=${LATEST_VERSION//\./-}
          echo "CURRENT_SUBSET=$CURRENT_SUBSET" >> k8-dev.env
          echo "NEW_VERSION=$DOCKER_TAG" >> k8-dev.env
          NEW_SUBSET=${NEW_VERSION//\./-}
          echo "NEW_SUBSET=$NEW_SUBSET" >> k8-dev.env
          echo "BASE_WEIGHT=75" >> k8-dev.env
          echo "CANARY_WEIGHT=25" >> k8-dev.env

      # create deployment files


      - run: j2 destinationrule-template.yaml k8-dev.env >> destinationrule-LATEST.yaml

      - run: j2 virtualservice-header-based-vs-template.yaml k8-dev.env >> virtual-service-header.yaml

      - run: j2 deployment-template.yaml k8-dev.env > deployment-$CURRENT_VERSION.yaml

      # now we have the files we need to deploy the new rules and then the container
      # first release the service to make sure it's there
      - run: kubectl apply -f service.yaml

      - run: |
          kubectl apply -f destinationrule-LATEST.yaml
          sleep 5

      - run: |
          kubectl apply -f virtual-service-header.yaml
          sleep 5

      - run: |
        # now we need a script to check on pod status before going on
          kubectl apply -f deployment-$CURRENT_VERSION.yaml

      # setup gateway
      - run: kubectl apply -f k8/gateway-final.yaml
      # setup virtual service
      - run: kubectl apply -f k8/virtualservice-final.yaml
      # sleep to let it all happen
      - run: sleep 60
      # now we test

workflows:
  version: 2

  btd:
    jobs:
#      - build-jar
#      - build-docker:
#          requires:
#            - build-jar
#      - deploy-service:
#          requires:
#            - build-docker